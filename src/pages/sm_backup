import React, { useState, useEffect, useRef } from "react";
import html2canvas from "html2canvas";
import "../components/common/css/Simulation_CSS.css";
import solarpanel1 from "../assets/SimulationPage/solarpanel1.png";
import solarpanel2 from "../assets/SimulationPage/solarpanel2.png";
import simulation_button from "../assets/SimulationPage/simulation_button.png";
import simulation_btn_mobile from "../assets/SimulationPage/simulation_btn_mobile.png";
import sunlight_btn from "../assets/SimulationPage/sunlight_btn.png";
import shadow_btn from "../assets/SimulationPage/shadow_btn.png";

import { useNavigate } from "react-router-dom";
import NaverMap from "../components/map/NaverMap";
import VMap from "../components/map/VMap";

//ì¶”
import LoadingAnimation from "./LodingAnimation";

const SimulationPage = () => {
  const [showPanel, setShowPanel] = useState(false);
  const [aiDetections, setAiDetections] = useState([]);
  const navigate = useNavigate();
  // ëª¨ë°”ì¼ í™”ë©´
  const [isMobile, setIsMobile] = useState(false);

  // ì§€ë„ ì „í™˜
  const [useVMap, setUseVMap] = useState(false);

  // ì§€ë„ ì¢Œí‘œ ë™ê¸°í™”
  const [centerLat, setCenterLat] = useState("");
  const [centerLon, setCenterLon] = useState("");

  const [showSolarOverlay, setShowSolarOverlay] = useState(false);
  const [placingPanel, setPlacingPanel] = useState(null);
  const [placingSize, setPlacingSize] = useState({ width: 0, height: 0 });
  const [placedPanels, setPlacedPanels] = useState([]);
  const [dragIndex, setDragIndex] = useState(null);
  const [resizeIndex, setResizeIndex] = useState(null); // âœ… ë¦¬ì‚¬ì´ì¦ˆ ëŒ€ìƒ ì¸ë±ìŠ¤
  const [isShiftPressed, setIsShiftPressed] = useState(false); // âœ… Shift ê³ ì • ì—¬ë¶€
  const [placingRotation, setPlacingRotation] = useState(0);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  const canvasRef = useRef(null);
  const placingPanelRef = useRef(placingPanel);
  const [aiPlacementMode, setAiPlacementMode] = useState(false);
  const polygonRefs = useRef([]); // ğŸ”µ ëª¨ë“  ìƒì„±ëœ Polygon ì €ì¥
  //ì¶”
  const [isLoading, setIsLoading] = useState(false);

  const cmToPx = (cm) => cm * 0.5;
  const MIN_WIDTH = 100;
  const MIN_HEIGHT = 40;
  const MAX_WIDTH = 500;
  const MAX_HEIGHT = 250;

  const [totalArea, setTotalArea] = useState(0);

  // ëª¨ë°”ì¼ í™”ë©´ ì²´í¬
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth <= 420);
    };

    checkMobile();
    window.addEventListener("resize", checkMobile);
    return () => window.removeEventListener("resize", checkMobile);
  }, []);

  // ìŠ¤í¬ë¡¤ë°” ì œê±°
  useEffect(() => {
    document.body.classList.add("no-scroll");
    return () => document.body.classList.remove("no-scroll");
  }, []);

  // AI ë©´ì  í™•ì¸
  useEffect(() => {
    window.onMapChanged = () => {
      setAiDetections([]);
    };
  }, []);
  /*
  useEffect(() => {
    const map = window.naverMap;
    if (!map || !map.getProjection) return;

    polygonRefs.current.forEach((p) => p.setMap(null)); // ğŸ§¹ ê¸°ì¡´ polygon ì œê±°
    polygonRefs.current = []; // ğŸ”„ ì´ˆê¸°í™”

    const proj = map.getProjection();

    const total = placedPanels.reduce((sum, panel) => {
      const { x, y, width, height, rotation } = panel;
      const center = { x, y };
      const rad = (rotation * Math.PI) / 180;

      const corners = [
        { dx: -width / 2, dy: -height / 2 },
        { dx: width / 2, dy: -height / 2 },
        { dx: width / 2, dy: height / 2 },
        { dx: -width / 2, dy: height / 2 },
      ].map(({ dx, dy }) => {
        const rotatedX = dx * Math.cos(rad) - dy * Math.sin(rad);
        const rotatedY = dx * Math.sin(rad) + dy * Math.cos(rad);
        return new window.naver.maps.Point(
          center.x + rotatedX,
          center.y + rotatedY
        );
      });

      const canvasRect = canvasRef.current.getBoundingClientRect();
      const geoCoords = corners.map((pt) => {
        const pageX = pt.x + canvasRect.left;
        const pageY = pt.y + canvasRect.top;
        return proj.fromPageXYToCoord(
          new window.naver.maps.Point(pageX, pageY)
        );
      });

      const polygon = new window.naver.maps.Polygon({
        paths: geoCoords,
        map: map,
        strokeColor: "#00f",
        strokeWeight: 3,
        fillOpacity: 0.1,
      });

      polygonRefs.current.push(polygon); // âœ… ì´ ì¤„ì´ í•„ìš”í•¨!!
      const area = polygon.getAreaSize();
      polygon.setMap(null); // ğŸ‘ˆ ì‹¤ì œ ì§€ìš°ê¸°

      return sum + area;
    }, 0);

    setTotalArea(total);
  }, [placedPanels]);
  */
  useEffect(() => {
    const map = window.naverMap;
    if (!map || !map.getProjection || !canvasRef.current) return;
  
    const proj = map.getProjection();
    const canvasRect = canvasRef.current.getBoundingClientRect();
  
    let total = 0;
  
    placedPanels.forEach((panel) => {
      const { x, y, width, height, rotation } = panel;
      const rad = (rotation * Math.PI) / 180;
  
      const corners = [
        { dx: -width / 2, dy: -height / 2 },
        { dx: width / 2, dy: -height / 2 },
        { dx: width / 2, dy: height / 2 },
        { dx: -width / 2, dy: height / 2 },
      ].map(({ dx, dy }) => {
        const rotatedX = dx * Math.cos(rad) - dy * Math.sin(rad);
        const rotatedY = dx * Math.sin(rad) + dy * Math.cos(rad);
        return new window.naver.maps.Point(x + rotatedX + canvasRect.left, y + rotatedY + canvasRect.top);
      });
  
      const geoCoords = corners.map(
        (pt) => proj.fromPageXYToCoord(new window.naver.maps.Point(pt.x, pt.y))
      );
  
      const polygon = new window.naver.maps.Polygon({ paths: geoCoords, map });
      const area = polygon.getAreaSize();
      polygon.setMap(null);
  
      total += area;
    });
  
    setTotalArea(total);
  }, [placedPanels]);


  useEffect(() => {
    placingPanelRef.current = placingPanel;
  }, [placingPanel]);

  useEffect(() => {
    const map = window.naverMap;
    if (!map) return;

    if (aiPlacementMode) {
      map.setOptions({ scrollWheel: false, draggable: false });
    } else {
      map.setOptions({ scrollWheel: true, draggable: true });
    }
  }, [aiPlacementMode]);

  useEffect(() => {
    if (!aiPlacementMode && placingPanel) {
      setPlacingPanel(null);
    }
  }, [aiPlacementMode, placingPanel]);

  // íŒ¨ë„ ë„êµ¬ ì°½ ì„¤ì •
  // const handleOpenPanel = () => setShowPanel(true);
  // const handleClosePanel = () => setShowPanel(false);
  // ê²€ìƒ‰ì°½ ë²„íŠ¼ í† ê¸€ê¸°ëŠ¥ ì„¤ì •
  // const handleSlideToggle = () => setShowAddressSlide(!showAddressSlide);

  // âœ… ì§€ë„ ë³€ê²½ ì‹œ AI ìœ¤ê³½ì„  ì´ˆê¸°í™”
  useEffect(() => {
    window.onMapChanged = () => {
      setAiDetections([]);
    };
  }, []);

  // âœ… ë§ˆìš°ìŠ¤ ì´ë™ ì¶”ì  + í¬ê¸° ì¡°ì ˆ
  useEffect(() => {
    const handleMouseMove = (e) => {
      setMousePosition({ x: e.clientX, y: e.clientY });
      if (resizeIndex !== null && canvasRef.current) {
        const rect = canvasRef.current.getBoundingClientRect();
        const panel = placedPanels[resizeIndex];
        const dx = e.clientX - rect.left - panel.x;
        const dy = e.clientY - rect.top - panel.y;
        let newWidth = Math.min(
          Math.max(Math.abs(dx) * 2, MIN_WIDTH),
          MAX_WIDTH
        );
        let newHeight = Math.min(
          Math.max(Math.abs(dy) * 2, MIN_HEIGHT),
          MAX_HEIGHT
        );

        // âœ… Shift ëˆ„ë¥´ë©´ ë¹„ìœ¨ ê³ ì •
        if (isShiftPressed) {
          const ratio = panel.width / panel.height;
          if (newWidth / newHeight > ratio) newWidth = newHeight * ratio;
          else newHeight = newWidth / ratio;
        }

        setPlacedPanels((prev) =>
          prev.map((p, i) =>
            i === resizeIndex ? { ...p, width: newWidth, height: newHeight } : p
          )
        );
      }
    };

    // âœ… í‚¤ ì…ë ¥ ì²˜ë¦¬ (Shift, íšŒì „)
    const handleKeyDown = (e) => {
      // ì—¬ê¸° ë¡œê·¸ ì°ì–´ë³´ì
      console.log("KEY DOWN:", e.key);

      if (e.key === "Shift") setIsShiftPressed(true);

      // 1ï¸âƒ£ placingPanel ìƒíƒœì¼ ë•Œ ìš°ì„  íšŒì „ ì²˜ë¦¬
      if (placingPanelRef.current) {
        if (e.key === "r" || e.key === "R") {
          console.log("placing R");
          setPlacingRotation((prev) => (prev + 45) % 360);
          return;
        }
        if (e.key === "q" || e.key === "Q") {
          console.log("placing Q");
          setPlacingRotation((prev) => (prev - 45 + 360) % 360);
          return;
        }
      }

      // 2ï¸âƒ£ ë“œë˜ê·¸ ì¤‘ íšŒì „
      if (dragIndex !== null) {
        if (e.key === "r" || e.key === "R") {
          console.log("dragIndex R");
          setPlacedPanels((prev) =>
            prev.map((panel, idx) =>
              idx === dragIndex
                ? { ...panel, rotation: (panel.rotation + 45) % 360 }
                : panel
            )
          );
        } else if (e.key === "q" || e.key === "Q") {
          console.log("dragIndex Q");
          setPlacedPanels((prev) =>
            prev.map((panel, idx) =>
              idx === dragIndex
                ? { ...panel, rotation: (panel.rotation - 45 + 360) % 360 }
                : panel
            )
          );
        }
      }
    };

    const handleKeyUp = (e) => {
      if (e.key === "Shift") setIsShiftPressed(false);
    };

    // âœ… íœ  íšŒì „
    const handleWheel = (e) => {
      const delta = e.deltaY > 0 ? 3 : -3;

      if (placingPanelRef.current) {
        setPlacingRotation((prev) => (prev + delta + 360) % 360);
        return;
      }

      if (dragIndex !== null) {
        e.preventDefault();
        setPlacedPanels((prev) =>
          prev.map((panel, idx) =>
            idx === dragIndex
              ? { ...panel, rotation: (panel.rotation + delta + 360) % 360 }
              : panel
          )
        );
      }
    };

    // âœ… ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);
    window.addEventListener("wheel", handleWheel, { passive: false });

    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
      window.removeEventListener("wheel", handleWheel);
    };
  }, [dragIndex, resizeIndex, isShiftPressed, placedPanels]);

  const tooltipRef = useRef(null);

  const showTooltip = (panel) => {
    const map = window.naverMap;
    if (!map) return;

    const { x, y, width, height, rotation } = panel;
    const center = { x, y };
    const rad = (rotation * Math.PI) / 180;

    const corners = [
      { dx: -width / 2, dy: -height / 2 },
      { dx: width / 2, dy: -height / 2 },
      { dx: width / 2, dy: height / 2 },
      { dx: -width / 2, dy: height / 2 },
    ].map(({ dx, dy }) => {
      const rotatedX = dx * Math.cos(rad) - dy * Math.sin(rad);
      const rotatedY = dx * Math.sin(rad) + dy * Math.cos(rad);
      return new window.naver.maps.Point(
        center.x + rotatedX,
        center.y + rotatedY
      );
    });

    const canvasRect = document
      .getElementById("naver-map")
      .getBoundingClientRect();
    const proj = map.getProjection();
    const geoCoords = corners.map((pt) =>
      proj.fromPageXYToCoord(
        new window.naver.maps.Point(
          pt.x + canvasRect.left,
          pt.y + canvasRect.top
        )
      )
    );

    // const polygon = new window.naver.maps.Polygon({ paths: geoCoords });
    // const area = polygon.getAreaSize();

    const polygon = new window.naver.maps.Polygon({
      paths: geoCoords,
      map: map, // âœ… í•„ìˆ˜: ì´ê²Œ ìˆì–´ì•¼ getAreaSizeê°€ ì‘ë™í•¨
      strokeColor: "#00f",
      fillOpacity: 0.1,
      strokeWeight: 1,
    });

    polygonRefs.current.push(polygon); // âœ… ë°°ì—´ì— ì €ì¥
    const area = polygon.getAreaSize();
    polygon.setMap(null); // âœ… ì§€ë„ì— ê·¸ë ¸ë˜ ê²ƒ ì œê±°

    if (tooltipRef.current) tooltipRef.current.close();

    tooltipRef.current = new window.naver.maps.InfoWindow({
      content: `<div style="background:#fff;border:1px solid #333;padding:4px 8px;font-size:12px;">ë©´ì : ${area.toFixed(
        2
      )}ã¡</div>`,
      pixelOffset: new window.naver.maps.Point(0, -10),
    });

    // geoCoordsê°€ ì•„ë‹Œ íŒ¨ë„ ì¤‘ì‹¬ì„ LatLngë¡œ ë³€í™˜í•´ì„œ InfoWindowì— ì‚¬ìš©
    const centerCoord = proj.fromPageXYToCoord(
      new window.naver.maps.Point(
        center.x + canvasRect.left,
        center.y + canvasRect.top
      )
    );

    tooltipRef.current.open(map, centerCoord); // â¬… ì¤‘ì‹¬ì— í‘œì‹œ
  };

  const hideTooltip = () => {
    if (tooltipRef.current) {
      tooltipRef.current.close();
      tooltipRef.current = null;
    }
  };

  // âœ… íŒ¨ë„ ì„¤ì¹˜
  const handleMapClick = (e) => {
    if (!placingPanel || !aiPlacementMode) return;
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    setPlacedPanels((prev) => [
      ...prev,
      {
        x,
        y,
        src: placingPanel,
        rotation: placingRotation,
        width: placingSize.width,
        height: placingSize.height,
      },
    ]);
    setPlacingPanel(null);
    setPlacingRotation(0);
  };

  // âœ… ë“œë˜ê·¸ ë° ë¦¬ì‚¬ì´ì¦ˆ ì¡°ì‘
  const handleDragStart = (index) => setDragIndex(index);
  const handleResizeStart = (index) => setResizeIndex(index);
  const handleMouseUp = () => {
    setDragIndex(null);
    setResizeIndex(null);
  };

  const handleDrag = (e) => {
    if (dragIndex === null) return;
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    setPlacedPanels((prev) =>
      prev.map((panel, idx) => (idx === dragIndex ? { ...panel, x, y } : panel))
    );
  };

  // âœ… ìš°í´ë¦­ ì‚­ì œ
  const handleRightClick = (e, index) => {
    e.preventDefault();
    setPlacedPanels((prev) => prev.filter((_, i) => i !== index));
  };

  const isNearCorner = (pos, panel) => {
    const margin = 10;
    const corners = [
      {
        x: panel.x - panel.width / 2,
        y: panel.y - panel.height / 2,
        name: "top-left",
      },
      {
        x: panel.x + panel.width / 2,
        y: panel.y - panel.height / 2,
        name: "top-right",
      },
      {
        x: panel.x + panel.width / 2,
        y: panel.y + panel.height / 2,
        name: "bottom-right",
      },
      {
        x: panel.x - panel.width / 2,
        y: panel.y + panel.height / 2,
        name: "bottom-left",
      },
    ];
    return corners.find(
      (c) => Math.abs(pos.x - c.x) < margin && Math.abs(pos.y - c.y) < margin
    )?.name;
  };

  // âœ… AI ì¶”ë¡  ìº¡ì²˜ ë° ì „ì†¡ - ë¡œë”© ê¸°ëŠ¥ ìˆ˜ì •
  const handleAIInference = async () => {
    setIsLoading(true); // ğŸ”„ ë¡œë”© ì‹œì‘

    const mapElement = document.querySelector(".simulation-canvas");
    if (!mapElement) {
      alert("ì§€ë„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
      setIsLoading(false);
      return;
    }

    const canvas = await html2canvas(mapElement, {
      useCORS: true,
      width: mapElement.offsetWidth,
      height: mapElement.offsetHeight,
    });

    const fullWidth = canvas.width;
    const fullHeight = canvas.height;
    const cropX = fullWidth * 0.1;
    const cropWidth = fullWidth * 0.8;
    const cropHeight = fullHeight;

    const croppedCanvas = document.createElement("canvas");
    croppedCanvas.width = cropWidth;
    croppedCanvas.height = cropHeight;

    const ctx = croppedCanvas.getContext("2d");
    ctx.drawImage(canvas, cropX, 0, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

    croppedCanvas.toBlob(async (blob) => {
      if (!blob) {
        setIsLoading(false);
        return;
      }
      const formData = new FormData();
      formData.append("image", blob, "cropped_map.png");

      try {
        const response = await fetch("http://localhost:8080/api/predict", {
          method: "POST",
          body: formData,
        });
        const result = await response.json();
        setAiDetections(result.detections);

        const map = window.naverMap;
        if (map) {
          setTimeout(() => {
            map.setOptions({ draggable: false, scrollWheel: false });
          }, 100);
        }

        // âœ… AI ë°°ì¹˜ ëª¨ë“œ ON
        setAiPlacementMode(true);

        const center = window.naverMap.getCenter();
        const lat = center.lat();
        const lng = center.lng();
        console.log("í˜„ì¬ ì§€ë„ ì¤‘ì‹¬ ìœ„ë„/ê²½ë„:", lat, lng);

      } catch (error) {
        console.error("AI ìš”ì²­ ì‹¤íŒ¨:", error);
      } finally {
        setIsLoading(false); // ğŸ”„ ë¡œë”© ì¢…ë£Œ
      }
    }, "image/png");
  };


  return (
    <div className="simulation-container">
      //ì¶”
      {isLoading && <LoadingAnimation />}
      <div className="simulation-body">
        <div className="simulation-map-area fullscreen-map">
          <div className="simulation-map-wrapper">
            <div
              className="simulation-canvas"
              id="simulation-canvas"
              ref={canvasRef}
              onClick={handleMapClick}
              onMouseMove={handleDrag}
              onMouseUp={handleMouseUp}
              style={{ position: "relative" }}
            >
              {useVMap ? (
                <VMap centerLat={centerLat} centerLon={centerLon} />
              ) : (
                <NaverMap
                  centerLat={centerLat}
                  centerLon={centerLon}
                  setCenterLat={setCenterLat}
                  setCenterLon={setCenterLon}
                  showSolarOverlay={showSolarOverlay}
                />
              )}

              {/* ì¤‘ì•™ ì˜ì—­ ì‹œê°í™” */}
              <div
                id="capture-area-box"
                style={{
                  position: "absolute",
                  top: 0,
                  left: "10%",
                  width: "80%",
                  height: "100%",
                  border: "2px dashed red",
                  backgroundColor: "rgba(0, 0, 0, 0.1)",
                  pointerEvents: "none",
                  zIndex: 998,
                }}
              ></div>

              {/* AI ë§ˆìŠ¤í¬ ê²°ê³¼ */}
              <svg
                id="ai-mask-svg"
                width="100%"
                height="100%"
                style={{
                  position: "absolute",
                  top: 0,
                  left: 0,
                  pointerEvents: "none",
                  zIndex: 999,
                }}
              >
                {aiDetections.map((det, idx) => {
                  const offsetX = window.innerWidth * 0.1;
                  return (
                    <g key={idx}>
                      <rect
                        x={det.box[0] + offsetX}
                        y={det.box[1]}
                        width={det.box[2] - det.box[0]}
                        height={det.box[3] - det.box[1]}
                        stroke="red"
                        strokeWidth="2"
                        fill="none"
                      />
                      {det.mask && det.mask.length > 2 && (
                        <polygon
                          points={det.mask
                            .map(([y, x]) => `${x + offsetX},${y}`)
                            .join(" ")}
                          fill="rgba(198, 245, 180, 0.03)"
                          stroke="rgba(100,200,100,0.4)"
                          strokeWidth="1"
                        />
                      )}
                    </g>
                  );
                })}
              </svg>

              {/* ğŸŸ¡ ë°°ì¹˜ëœ íŒ¨ë„ ì´ë¯¸ì§€ */}
              {placedPanels.map((panel, idx) => {
                const corner = isNearCorner(mousePosition, panel);
                const cursor = corner ? "nwse-resize" : "move";
                return (
                  <img
                    key={idx}
                    src={panel.src}
                    alt={`panel-${idx}`}
                    style={{
                      position: "absolute",
                      top: panel.y,
                      left: panel.x,
                      width: panel.width,
                      height: panel.height,
                      transform: `translate(-50%, -50%) rotate(${panel.rotation}deg)`,
                      cursor,
                      zIndex: 1000,
                    }}
                    onMouseDown={() => {
                      if (corner) handleResizeStart(idx, corner);
                      else handleDragStart(idx);
                    }}
                    onContextMenu={(e) => handleRightClick(e, idx)}
                    onMouseEnter={() => showTooltip(panel)}
                    onMouseLeave={hideTooltip}
                  />
                );
              })}
            </div>
            {/* âœ… ë§ˆìš°ìŠ¤ë¥¼ ë”°ë¼ë‹¤ë‹ˆëŠ” ì„¤ì¹˜ íŒ¨ë„ ì´ë¯¸ì§€ */}
            {placingPanel && (
              <img
                src={placingPanel}
                alt="placing"
                style={{
                  position: "fixed",
                  top: mousePosition.y,
                  left: mousePosition.x,
                  // width: "80px",
                  width: placingSize.width,
                  height: placingSize.height,
                  transform: `translate(-50%, -50%) rotate(${placingRotation}deg)`,
                  pointerEvents: "none",
                  zIndex: 2000,
                }}
              />
            )}

            {/* íŒ¨ë„ ë³´ê¸° ë²„íŠ¼ */}
            <div className="panel-button-topright">
              <button
                className="open-panel-button"
                onClick={() => setShowPanel(true)}
              >
                <img
                  src={isMobile ? simulation_btn_mobile : simulation_button}
                  alt="íŒ¨ë„ ë³´ê¸° ë²„íŠ¼"
                />
              </button>
            </div>

            {/* íŒ¨ë„ íŒì—… */}
            {showPanel && (
              <div className="popup-panel">
                <div className="popup-panel-content">
                  <div className="close-btn-layout">
                    <h2>íŒ¨ë„ ì„¤ì •</h2>
                    <div
                      className="close-button-area"
                      onClick={() => setShowPanel(false)}
                    >
                      <img src={simulation_button} alt="ì„¤ì¹˜ íŒ¨ë„ ë‹«ê¸°" />
                    </div>
                  </div>
                  {/* <h2>ì„¤ì¹˜ íŒ¨ë„ ìƒì„¸</h2> */}
                  <div className="panel-content-row">
                    <div className="panel-image-selection">
                      <div className="panel-image-box">
                        <img
                          src={solarpanel1}
                          alt="íŒ¨ë„1"
                          className="panel-image panel-small"
                          onClick={() => {
                            if (!aiPlacementMode) return; // âœ… AI ëª¨ë“œ ì•„ë‹ ë• ë¬´ì‹œ
                            setPlacingPanel(solarpanel1);
                            setPlacingSize({
                              width: cmToPx(165),
                              height: cmToPx(99),
                            });
                          }}
                        />
                        <div className="panel-size">165cm x 99cm</div>
                      </div>
                      <div className="panel-image-box">
                        <img
                          src={solarpanel2}
                          alt="íŒ¨ë„2"
                          className="panel-image panel-large"
                          onClick={() => {
                            if (!aiPlacementMode) return; // âœ… AI ëª¨ë“œ ì•„ë‹ ë• ë¬´ì‹œ
                            setPlacingPanel(solarpanel2);
                            setPlacingSize({
                              width: cmToPx(198),
                              height: cmToPx(99),
                            });
                          }}
                        />
                        <div className="panel-size">198cm x 99cm</div>
                      </div>
                    </div>
                    <div className="panel-form-section">
                      <div className="panel-info">
                        <label className="panel-label">ì„¤ì¹˜ ê°œìˆ˜</label>
                        <input
                          type="number"
                          value={placedPanels.length}
                          className="panel-input"
                          readOnly
                        />
                      </div>
                      <div className="panel-info">
                        <label className="panel-label">ì„¤ì¹˜ ë©´ì </label>
                        <input
                          type="text"
                          value={`${totalArea.toFixed(2)} ã¡`}
                          className="panel-result-input"
                          readOnly
                        />
                      </div>
                      <div className="panel-info">
                        <label className="panel-label">ì‹¤ì œ ì„¤ì¹˜ ê°€ëŠ¥ ìˆ˜</label>
                        <input
                          type="text"
                          value={`${Math.floor(totalArea / 2)} ê°œ`}
                          className="panel-input"
                          readOnly
                        />
                      </div>
                      <div className="panel-info">
                        <label className="panel-label">
                          ì˜ˆìƒ ì—ë„ˆì§€ ìƒì‚°ëŸ‰
                        </label>
                        <input
                          type="text"
                          value={`${(Math.floor(totalArea / 2) * 3.5).toFixed(
                            1
                          )} kWh`}
                          className="panel-result-input"
                          readOnly
                        />
                      </div>
                      <div className="panel-info">
                        <label className="panel-label">ì„¤ì¹˜ ëª©ë¡</label>
                        <ul className="panel-list">
                          {placedPanels.map((p, i) => (
                            <li key={i}>
                              {p.src.includes("solarpanel1")
                                ? "íŒ¨ë„1"
                                : "íŒ¨ë„2"}{" "}
                              - íšŒì „: {p.rotation}Â°
                              <button
                                onClick={() =>
                                  handleRightClick(
                                    { preventDefault: () => { } },
                                    i
                                  )
                                }
                              >
                                X
                              </button>
                            </li>
                          ))}
                        </ul>
                      </div>
                    </div>
                  </div>

                  <hr className="panel-divider" />

                  <div className="chart-wrapper">
                    <div className="chart-box">
                      <span className="chart-placeholder-text">
                        AI ì¶”ì²œ vs ì‚¬ìš©ì ë°œì „ëŸ‰ ì°¨íŠ¸ ê³µê°„
                      </span>
                    </div>
                    <div className="chart-box">
                      <span className="chart-placeholder-text">
                        ì„¤ì¹˜ ì¼ì¹˜ìœ¨ ì°¨íŠ¸ ê³µê°„
                      </span>
                    </div>
                  </div>

                  <div className="complete-button-wrapper">
                    <button
                      className="ai-input-button"
                      onClick={handleAIInference}
                    >
                      AI ìë™ ë°°ì¹˜
                    </button>
                    <button
                      className="clear-ai-button"
                      onClick={() => {
                        setAiDetections([]);

                        setPlacedPanels([]); // ğŸ‘‰ ì„¤ì¹˜ íŒ¨ë„ ì´ˆê¸°í™”
                        setAiPlacementMode(false);
                        // ğŸ”µ íŒŒë€ Polygon ì „ë¶€ ì œê±°
                        polygonRefs.current.forEach((p) => p.setMap(null));
                        polygonRefs.current = []; // ë°°ì—´ ë¹„ìš°ê¸°
                        const map = window.naverMap;
                        if (map) {
                          map.setOptions({
                            draggable: true,
                            scrollWheel: true,
                          });
                        }
                      }}
                    >
                      AI ë°°ì¹˜ ì·¨ì†Œ
                    </button>
                    <button
                      className="complete-button"
                      onClick={() => navigate("/result")}
                    >
                      ë°°ì¹˜ ì™„ë£Œ
                    </button>
                  </div>
                </div>
              </div>
            )}

            {/* ê·¸ë¦¼ì ë¶„ì„ ë§µ ì „í™˜ ë²„íŠ¼ */}
            <div className="switch-btn">
              <button
                className="switch-button"
                onClick={() => setUseVMap((prev) => !prev)}
              >
                <img src={shadow_btn} alt="ë§µ ì „í™˜ ë²„íŠ¼" />
              </button>
            </div>

            {/* ì¼ì¡°ëŸ‰ ë²„íŠ¼ */}
            <div className="sunlight-filter-button">
              <button
                className="filter-button"
                onClick={() => setShowSolarOverlay((prev) => !prev)}
              >
                <img src={sunlight_btn} alt="ì¼ì¡°ëŸ‰ ë²„íŠ¼" />
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SimulationPage;
